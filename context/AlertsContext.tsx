import React, {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
  type ReactNode,
} from 'react';
import { AppState, type AppStateStatus } from 'react-native';
import { useLocation, type LocationData } from '@/hooks/useLocation';
import { getAlerts, clearAlertsCache } from '@/services/alertsApiService';

export type AlertSeverity = 'low' | 'medium' | 'high';

export interface AlertItem {
  id?: string; // present for global alerts from backend; autogenerated for local alerts
  title: string;
  description: string;
  severity: AlertSeverity;
  startOn: Date; // JS Date after conversion from Firestore timestamp
  endOn: Date;   // JS Date after conversion from Firestore timestamp
  locations: string[]; // affected locations
  createdOn?: Date;
  source?: 'global' | 'local';
}

export interface AlertsContextProps {
  globalAlerts: AlertItem[];
  localAlerts: AlertItem[];
  loading: boolean;
  error: string | null;
  lastFetchedAt: Date | null;
  refreshGlobalAlerts: (options?: { force?: boolean }) => Promise<void>;
  addLocalAlert: (alert: Omit<AlertItem, 'id' | 'source'> & { id?: string }) => string;
  removeLocalAlert: (id: string) => void;
  clearLocalAlerts: () => void;
}

const AlertsContext = createContext<AlertsContextProps | undefined>(undefined);

function buildLocationData(
  params: Partial<LocationData> & { loading?: boolean }
): LocationData | null {
  // If still loading and we have no meaningful strings yet, return null.
  const { loading, latitude, longitude, suburb, city, state, region, country } = params;
  const hasAnyLocationString = Boolean(suburb || city || state || region || country);
  if (loading && !hasAnyLocationString) return null;

  return {
    latitude: latitude ?? 0,
    longitude: longitude ?? 0,
    suburb: suburb ?? '',
    city: city ?? '',
    state: state ?? '',
    region: region ?? (state ?? ''),
    country: country ?? '',
  };
}

export function AlertsProvider({ children }: { children: ReactNode }) {
  const location = useLocation();

  const [globalAlerts, setGlobalAlerts] = useState<AlertItem[]>([]);
  const [localAlerts, setLocalAlerts] = useState<AlertItem[]>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [lastFetchedAt, setLastFetchedAt] = useState<Date | null>(null);

  const isMountedRef = useRef(true);
  const isFetchingRef = useRef(false);

  useEffect(() => {
    return () => {
      isMountedRef.current = false;
    };
  }, []);

  const doFetchGlobalAlerts = useCallback(
    async (options?: { force?: boolean }) => {
      if (isFetchingRef.current) return;
      isFetchingRef.current = true;
      setLoading(true);
      setError(null);

      try {
        if (options?.force) {
          await clearAlertsCache();
        }

        const locData = buildLocationData({
          loading: location.loading,
          latitude: location.latitude,
          longitude: location.longitude,
          suburb: location.suburb,
          city: location.city,
          state: location.state,
          region: location.region,
          country: location.country,
        });

        // If we truly have nothing yet, skip until we do.
        if (!locData) {
          return;
        }

        // getAlerts handles: 6-hour cache window, Firestore timestamp conversion,
        // backend fetch, and fallback to cached data on errors.
        const fetched = await getAlerts(locData);
        if (!isMountedRef.current) return;

        const normalized = (fetched ?? []).map((a) => ({
          ...a,
          source: 'global' as const,
        }));
        setGlobalAlerts(normalized);
        setLastFetchedAt(new Date());
        setError(null);
      } catch (e: any) {
        if (!isMountedRef.current) return;
        setError(e?.message || 'Failed to fetch alerts');
      } finally {
        if (isMountedRef.current) setLoading(false);
        isFetchingRef.current = false;
      }
    },
    [
      location.loading,
      location.latitude,
      location.longitude,
      location.suburb,
      location.city,
      location.state,
      location.region,
      location.country,
    ]
  );

  // Auto-fetch when a meaningful location becomes available or changes.
  useEffect(() => {
    const hasLocationStrings = Boolean(
      location.suburb || location.city || location.state || location.region || location.country
    );
    if (!location.loading && hasLocationStrings) {
      doFetchGlobalAlerts();
    }
    // We intentionally depend on location fields in doFetchGlobalAlerts dependency array.
  }, [location.loading, location.suburb, location.city, location.state, location.region, location.country, doFetchGlobalAlerts]);

  // Optional: When app comes to foreground, try a fetch (service will respect 6h window)
  useEffect(() => {
    const handler = (state: AppStateStatus) => {
      if (state === 'active') {
        doFetchGlobalAlerts();
      }
    };
    const sub = AppState.addEventListener('change', handler);
    return () => sub.remove();
  }, [doFetchGlobalAlerts]);

  const addLocalAlert = useCallback<
    AlertsContextProps['addLocalAlert']
  >((alert) => {
    const id = alert.id ?? `local-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    const normalized: AlertItem = {
      ...alert,
      id,
      source: 'local',
    };
    setLocalAlerts((prev) => [normalized, ...prev]);
    return id;
  }, []);

  const removeLocalAlert = useCallback<
    AlertsContextProps['removeLocalAlert']
  >((id) => {
    setLocalAlerts((prev) => prev.filter((a) => a.id !== id));
  }, []);

  const clearLocalAlerts = useCallback(() => setLocalAlerts([]), []);

  const value = useMemo<AlertsContextProps>(
    () => ({
      globalAlerts,
      localAlerts,
      loading,
      error,
      lastFetchedAt,
      refreshGlobalAlerts: doFetchGlobalAlerts,
      addLocalAlert,
      removeLocalAlert,
      clearLocalAlerts,
    }),
    [globalAlerts, localAlerts, loading, error, lastFetchedAt, doFetchGlobalAlerts, addLocalAlert, removeLocalAlert]
  );

  return <AlertsContext.Provider value={value}>{children}</AlertsContext.Provider>;
}

export function useAlerts(): AlertsContextProps {
  const ctx = useContext(AlertsContext);
  if (!ctx) {
    throw new Error('useAlerts must be used within an AlertsProvider');
  }
  return ctx;
}

