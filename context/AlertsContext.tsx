import React, {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
  type ReactNode,
} from 'react';
import { AppState, type AppStateStatus } from 'react-native';
import { useLocation, type LocationData } from '@/hooks/useLocation';
import { useSession } from '@/context/SessionContext';
import { getAlerts, clearAlertsCache } from '@/services/alertsApiService';

export type AlertSeverity = 'low' | 'medium' | 'high';

export interface AlertItem {
  id?: string; // present for global alerts from backend; autogenerated for local alerts
  title: string;
  description: string;
  severity: AlertSeverity;
  startOn: Date;
  endOn?: Date;
  locations: string[]; // affected locations
  target: 'traveler' | 'tourGuide' | 'everyone';
  createdOn?: Date;
  source?: 'global' | 'local';
  state: 'unread' | 'read';
}

export interface AlertsContextProps {
  globalAlerts: AlertItem[];
  localAlerts: AlertItem[];
  loading: boolean;
  error: string | null;
  lastFetchedAt: Date | null;
  refreshGlobalAlerts: (options?: { force?: boolean }) => Promise<void>;
  addLocalAlert: (alert: Omit<AlertItem, 'id' | 'source'> & { id?: string }) => string;
  removeLocalAlert: (id: string) => void;
  clearLocalAlerts: () => void;
  markAsRead: (id: string) => void;
}

const AlertsContext = createContext<AlertsContextProps | undefined>(undefined);

function buildLocationData(
  params: Partial<LocationData> & { loading?: boolean }
): LocationData | null {
  // If still loading and we have no meaningful strings yet, return null.
  const { loading, latitude, longitude, suburb, city, state, region, country } = params;
  const hasAnyLocationString = Boolean(suburb || city || state || region || country);
  if (loading && !hasAnyLocationString) return null;

  return {
    latitude: latitude ?? 0,
    longitude: longitude ?? 0,
    suburb: suburb ?? '',
    city: city ?? '',
    state: state ?? '',
    region: region ?? (state ?? ''),
    country: country ?? '',
  };
}

export function AlertsProvider({ children }: { children: ReactNode }) {
  const location = useLocation();
  const { session } = useSession();

  const [globalAlerts, setGlobalAlerts] = useState<AlertItem[]>([]);
  const [localAlerts, setLocalAlerts] = useState<AlertItem[]>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [lastFetchedAt, setLastFetchedAt] = useState<Date | null>(null);

  // Clear any local alerts on app start (remove test data)
  useEffect(() => {
    setLocalAlerts([]);
  }, []);

  const isMountedRef = useRef(true);
  const isFetchingRef = useRef(false);

  useEffect(() => {
    return () => {
      isMountedRef.current = false;
    };
  }, []);

  const doFetchGlobalAlerts = useCallback(
    async (options?: { force?: boolean }) => {
      if (isFetchingRef.current) return;
      isFetchingRef.current = true;
      setLoading(true);
      setError(null);

      try {
        if (options?.force) {
          await clearAlertsCache();
        }

        const locData = buildLocationData({
          loading: location.loading,
          latitude: location.latitude,
          longitude: location.longitude,
          suburb: location.suburb,
          city: location.city,
          state: location.state,
          region: location.region,
          country: location.country,
        });

        // If we truly have nothing yet, skip until we do.
        if (!locData) {
          return;
        }

        // getAlerts handles: 6-hour cache window, Firestore timestamp conversion,
        // backend fetch, and fallback to cached data on errors.
        const userType = session?.user?.type || 'traveler';
        const fetched = await getAlerts(locData, userType);
        if (!isMountedRef.current) return;

        const normalized = (fetched ?? []).map((a) => ({
          ...a,
          target: a.target || 'everyone' as const,
          source: 'global' as const,
          state: 'unread' as const,
        }));
        setGlobalAlerts(normalized);
        setLastFetchedAt(new Date());
        setError(null);
      } catch (e: any) {
        setError(e?.message || 'Failed to fetch alerts');
      } finally {
        if (isMountedRef.current) setLoading(false);
        isFetchingRef.current = false;
      }
    },
    [
      location.loading,
      location.latitude,
      location.longitude,
      location.suburb,
      location.city,
      location.state,
      location.region,
      location.country,
      session?.user?.type,
    ]
  );

  // Auto-fetch when a meaningful location becomes available or changes.
  useEffect(() => {
    const hasLocationStrings = Boolean(
      location.suburb || location.city || location.state || location.region || location.country
    );
    if (!location.loading && hasLocationStrings) {
      // Clear cache and force fresh fetch to remove any test alerts
      doFetchGlobalAlerts({ force: true });
    }
    // We intentionally depend on location fields in doFetchGlobalAlerts dependency array.
  }, [location.loading, location.suburb, location.city, location.state, location.region, location.country, doFetchGlobalAlerts]);

  // Optional: When app comes to foreground, try a fetch (service will respect 6h window)
  useEffect(() => {
    const handler = (state: AppStateStatus) => {
      if (state === 'active') {
        doFetchGlobalAlerts();
      }
    };
    const sub = AppState.addEventListener('change', handler);
    return () => sub.remove();
  }, [doFetchGlobalAlerts]);
// Schedule automatic cache clear & refetch at 6-hour windows (6am,12pm,6pm,12am)
  useEffect(() => {
    const scheduleNext = () => {
      const now = new Date();
      const fetchHours = [0, 6, 12, 18];
      let nextHour = fetchHours.find(h => now.getHours() < h);
      const next = new Date(now);
      if (nextHour === undefined) {
        nextHour = fetchHours[0];
        next.setDate(now.getDate() + 1);
      }
      next.setHours(nextHour, 0, 0, 0);
      const delay = next.getTime() - now.getTime();
      setTimeout(async () => {
        await clearAlertsCache();
        await doFetchGlobalAlerts({ force: true });
        scheduleNext();
      }, delay);
    };
    scheduleNext();
  }, [doFetchGlobalAlerts]);

  const addLocalAlert = useCallback<
    AlertsContextProps['addLocalAlert']
  >((alert) => {
    const id = alert.id ?? `local-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    const normalized: AlertItem = {
      ...alert,
      id,
      source: 'local',
      state: 'unread',
    };
    setLocalAlerts((prev) => [normalized, ...prev]);
    return id;
  }, []);

  const removeLocalAlert = useCallback<
    AlertsContextProps['removeLocalAlert']
  >((id) => {
    setLocalAlerts((prev) => prev.filter((a) => a.id !== id));
  }, []);

  const clearLocalAlerts = useCallback(() => setLocalAlerts([]), []);

  const markAsRead = useCallback<AlertsContextProps['markAsRead']>((id) => {
    setGlobalAlerts((prev) => 
      prev.map((alert) => 
        alert.id === id ? { ...alert, state: 'read' } : alert
      )
    );
    setLocalAlerts((prev) => 
      prev.map((alert) => 
        alert.id === id ? { ...alert, state: 'read' } : alert
      )
    );
  }, []);

  const value = useMemo<AlertsContextProps>(
    () => ({
      globalAlerts,
      localAlerts,
      loading,
      error,
      lastFetchedAt,
      refreshGlobalAlerts: doFetchGlobalAlerts,
      addLocalAlert,
      removeLocalAlert,
      clearLocalAlerts,
      markAsRead,
    }),
    [globalAlerts, localAlerts, loading, error, lastFetchedAt, doFetchGlobalAlerts, addLocalAlert, removeLocalAlert, markAsRead]
  );

  return <AlertsContext.Provider value={value}>{children}</AlertsContext.Provider>;
}

export function useAlerts(): AlertsContextProps {
  const ctx = useContext(AlertsContext);
  if (!ctx) {
    throw new Error('useAlerts must be used within an AlertsProvider');
  }
  return ctx;
}

